---
CIP: 113
Title: Programmable token-like assets
Category: Tokens
Status: Proposed
Authors:
    - Michele Nuzzi <michele.nuzzi.204@gmail.com>
    - Harmonic Laboratories <harmoniclabs@protonmail.com>
    - Matteo Coppola <m.coppola.mazzetti@gmail.com>
Implementors: []
Discussions:
    - https://github.com/cardano-foundation/CIPs/pull/444
Created: 2023-01-14
License: CC-BY-4.0
---

## Abstract
This CIP proposes a standard that if adopted would allow the same level of programmability of other ecosistems at the price of the token true ownership.

This is achieved imitating the way the account model works laveraging the UTxO structure adopted by Cardano.

## Motivation: why is this CIP necessary?

This CIP proposes a solution at the Cardano Problem Statement 3 ([CPS-0003](https://github.com/cardano-foundation/CIPs/pull/382/files?short_path=5a0dba0#diff-5a0dba075d998658d72169818d839f4c63cf105e4d6c3fe81e46b20d5fd3dc8f)).

If adopted it would allow to introduce the programmability over the transfer of tokens (meta-tokens) and their lifecycle.

The solution proposed includes (answering to the open questions of CPS-0003):

1 and 2) very much like account based models, wallets supporting this standard will require to know the address of the smart contract (validator)

3) the solution can co-exist with the existing native tokens

4) the implementation is possible without hardfork since Vasil

5) optimized implementations SHOULD NOT take significant computation, especially on transfers.

## Specification

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED",  "MAY", and
"OPTIONAL" in this document are to be interpreted as described in
[RFC 2119](https://datatracker.ietf.org/doc/html/rfc2119).

In the specification we'll use the haskell data type `Data`:
```hs
data Data
    = Constr Integer [Data]
    | Map [( Data, Data )]
    | List [Data]
    | I Integer
    | B ByteString
```

and we'll use the [plu-ts syntax for structs definition](https://pluts.harmoniclabs.tech/docs/onchain/Values/Structs/definition#pstruct) as an abstraction over the `Data` type.

The core idea of the implementation is to emulate the ERC20 standard; where tokens are entries in a map with addresses (or credentials in our case) as key and integers (the balances) as value. ([see the OpenZeppelin implementation for reference](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/9b3710465583284b8c4c5d2245749246bb2e0094/contracts/token/ERC20/ERC20.sol#L16));

Unlike the ERC20 standard; this CIP:

- allows for multiple entries with the same key (same credentials can be used for multiple accounts)
- DOES NOT include an equivalent of the `transferFrom` method; if needed it can be added by a specific implementation but it won't be considered part of the standard.

> **NOTE**
>
> the UTxO model allows for multiple transfers in one transaction
>
> this would allow for a more powerful model than the account based equivalent but implies higher execution costs
>
> with the goal of keeping the standard interoperable and easy to understand and implement
> in this first implementation we restricts transfers from a single account to a single account
>
> if necessary; this restriction might be dropped in a future version of the CIP 


The implementation requires

- a parameterized minting policy to validate the creation of new accounts (in this CIP also referred as `accountFactory`)
- a spending validator to manage the accounts (in this CIP also referred as `accountManager`)

### standard data types used

We'll need to use some data types as defined in the script context;

```ts
const PTxId = pstruct({
    PTxId: { txId: bs }
});

const PTxOutRef = pstruct({
    PTxOutRef: {
        id: PTxId.type,
        index: int
    }
});

const PCredential = pstruct({
    PPubKeyCredential: { pkh: bs },
    PScriptCredential: { valHash: bs },
});

const PCurrencySymbol = palias( bs );
```
which are equivalent to the data:
```hs
-- PTxId
Constr 0 [ B txId ]

--- PTxOutRef
Constr 0 [ PTxId, I index ]

-- PPubKeyCredential
Constr 0 [ B pkh ]

-- PScriptCredential
Constr 1 [ B valHash ]

-- PCurrencySymbol
B currencySym
```

### `accountFactory` (minting policy)

The `accountFactory` contract is responsabile of validating the creation of new accounts.

### validation logic

For the creation of the account to be considered valid (the minting policy suceeds)
it MUST result in a single asset minted going to an address with payment credentials equalst to an hard-coded (parametrized) `accountManager` contract,
and it is RECOMMENDED to have stake credentials equals to the stake cretentials of the user (if any) that SHOULD be inferred by the input utxo chosen to derive the name of the asset minted.

The choice to preserve the stake credentials is done to facilitate the query of the user's accounts in the offchain.

the standard redeemer for the `accountFactory` MUST have at least one constructor (with index `0`) with a single field being an integer,
used to determine which input is intended to be of the user.

the minimal definition would then be:
```ts
const AccountFactoryRdmr = pstruct({
    New: { inputIdx: int }
});
```

the input at the index given by the redeemer is used to deterime `userUtxoRef` (the utxo ref of the input) and `userUtxo` (the resolved input)

It is then RECOMMENDED to include a second constructor for the redeemer meant to signal the burning of an asset under that policy,
so a more complete definition would be
```ts
const AccountFactoryRdmr = pstruct({
    New: { inputIdx: int }, // Mint
    Delete: {} // Burn, not required by standard
});
```

the data needed from the `ScriptContext` includes the following fields:

- `inputs`
- `output`
- `mint`

used as follows:

- all the transaction inputs MUST NOT include any tokens having the same currency symbol of the `accountFactory` minting policy;
optionally a specific implementation MAY require a fixed number of inputs (eg. a single input) for performance reasons.

- when minting assets, only a single token under the policy MUST be minted (indipendently from the number of inputs)
- the only asset minted MUST have an unique asset name (we suggest using the output of `[(builtin sha2_256) [(builtin serialiseData) userUtxoRef]]` where `userUtxoRef` is the utxo reference (or `PTxOutRef`) of the very first input of the transaction)

- the asset minted MUST be included in an output of the transaction being validated going to the address as specified above (MUST have payment credentials of the the hard-coded `accountManager` validator, and SHOULD have stake credtentials of the user if any).

- the output going to the `accountManager` validator MUST implement the following checks (in addition to the presence of the minted asset):
    - the address' payment credential MUST have `ScriptCredential` constructor (constructor index `1`) and validator hash MUST equal the hard coded `accountManager` hash
    - the value attached to the UTxO MUST only have 2 entries (ADA and minted token) to prevent DoS by token spam.
    - the output datum MUST:
        - be constructed using the `InlineDatum` consturctor (consturctor index `2`)
        - have datum value with the [`Account` structure (explained below)](#Account) with the following fields:
            - amount: `0`
            - currencySym: currency symbol of the `accountFactory` minting policy (own currency symbol)
            - credentials: the `userUtxo` address payment credentials (both public key hash and validator hash supported)
            - state: no restrictions (up to the specific implementaiton).

### `accountManager` (spending validator)

The `accountManager` contract is responsabile of managing exsiting accounts and their balances.

This is done using some standard redeemers and optionally some implementation-specfic ones.

### `Account`

The `Account` data type is used as the `accountManager` datum; and is defined as follows:

```ts
const Account = pstruct({
    Account: {
        amount: int,
        credentials: PCredential.type,
        currencySym: PCurrencySymbol.type,
        state: data
    }
});
```

> **NOTE:**
>
> the `state` field is indicated here as `data`, meaning that anything that is data-like can be used;
> the standard redeemers will only check for not to change;
>
> for the `state` field to be changed, some implementation-specific redeemer MAY be added
>
> example; this is considered a valid datum definition by the standard:
>
> ```ts
> // implementation-specific state
> const FreezeableAccountState = pstruct({
>     Ok: {}, // Constr index 0; free to spend
>     Frozen: {} // Constr index 1; frozen
> });
> 
> const FreezeableAccount = pstruct({
>     Account: {
>         amount: int,
>         credentials: PCredential.type,
>         currencySym: PCurrencySymbol.type,
>         state: FreezeableAccountState.type
>     }
> });
> ```

### `AccountManagerRedeemer`

The `AccountManagerRedeemer` is used to comunicate the contract the intention with which the utxo is being spent.

It MUST define 4 standard redeemers; none of which is meant to manipulate the state of the spending account.

for this reason a specific implementation will likely have more than 4 possible redeemers that will NOT be considered standard
(eg. a wallet implementing an interface SHOULD NOT depend on the exsistence of these additional redeemers).

The minimal `AccountManagerRedeemer` is:

```ts
const AccountManagerRedeemer = pstruct({
    Mint: { // or Burn if `amount` is negative
        amount: int
    },
    Transfer: {
        to: PCredential.type,
        amount: int
    },
    Receive: {},
    ForwardCompatibility: {}
});
```

The validation logic is different for each redeemer.

#### Common operations and values

Before proceeding with the redeemers validation logic here are some common operations and values between some of the redeemers.

##### `ownUtxoRef`

the `accountManager` contract is meant to be used only as spending validator.

As such we can extract the utxo being spent from the `ScriptPurpose` when constructed with the `Spending` constructor and fail for the rest.

```ts
const ownUtxoRef = plet(
    pmatch( ctx.purpose )
    .onSpending(({ utxoRef }) => utxoRef)
    ._( _ => perror( PTxOutRef.type ) )
);
```

##### `validatingInput`

is the input with `utxoRef` field equivalent to `ownUtxoRef`

```ts
const validatingInput = plet(
    pmatch(
        tx.inputs.find( i => i.utxoRef.eq( ownUtxoRef ) )
    )
    .onJust(({ val }) => val.resolved )
    .onNothing(_ => perror( PTxOut.type ) )
);
```

##### `ownCreds`

from the `validatingInput`:

```ts
validatingInput.resolved.address.credential
```

##### `ownValue`

from the `validatingInput`:

```ts
validatingInput.resolved.value
```

##### `isOwnOutput`

given an output; we recongize the output as "own" if the attached credentials are equivalent to `ownCreds` 
and the attached value includes an entry for the `currencySym` field in the specified in the datum (making sure the same `accountFactory` was used).

> **NOTE:**
>
> We compare only the payment credentials; NOT the entire address
>
> outputs that are under different stake credentials are meant only to facilitate the offchain queries, but still considered as "own"

```ts
const isOwnOutput = plet(
    pfn([ PTxOut.type ], bool )
    ( out => 
        out.address.credential.eq( ownCreds )
        // a single account manager contract might handle multiple tokens
        .and(
            out.value.some( ({ fst: policy }) => policy.eq( account.currencySym ) )
        ) 
    )
);
```

##### `isOwnInput` 

an input is "own" if the resolved field is "own";

```ts
const isOwnInput = plet(
    pfn([ PTxInInfo.type ], bool )
    ( input => isOwnOutput.$( input.resolved ) )
);
```

##### `isOwnCurrencySym`

given an asset policy we might want to know if it is the one being validated.

this is done by comparing it with the one specified in the datum field

```ts
const isOwnCurrSym = plet( account.currencySym.peq );
```

##### `outIncludesNFT`

given a transaction output is useful to check if the value includes the NFT generated from the `accountFactory`;

this is done by checking that at least one of the attached value's entry satisfies `isOwnCurrencySym` for the policy.

```ts
 const outIncludesNFT = plet(
    pfn([ PTxOut.type ], bool )
    ( out => out.value.some( entry => isOwnCurrSym.$( entry.fst ) ) )
);
```

##### `ownOuts`

transaction outputs filtered by `isOwnOutput`;

##### `ownInputs`

transaction inputs filtered by `isOwnInput`;

##### updating the `Account` datum

Between all the standard redeemers it MUST be checked that the datum fields `credentials`, `currencySym` and `state` remain unchanged compared to the current datum.

the `amount` field MAY change according to the purpose of the redeemer.

This MAY NOT be true for any additional implementation-specific redeemer.

#### `Mint`

the contract being called using the `Mint` redeemer MUST succeed only if the following conditions are met:

> **NOTE** 
>
> we use `mint.amount` to describe the value of the `amount` field included in the `Mint` redeemer
> and `account.amount` to describe the value of the `amount` field included in the input `Account` datum.

- there MUST be only a single input is from the `accountManager` validator (aka. `ownInputs.length.eq( 1 )`);

- the minted value in the transaction (`ctx.tx.mint`) MUST NOT include any entry with `PCurrencySymbol`
equivalent to the one specified in the `currencySym` field of the `Account` datum (aka. no accounts are created)

```ts
const noAccountsCreated = pisEmpty.$(
    tx.mint.filter( isOwnAssetEntry )
);
```

- the input value coming from the `accountManager` MUST include an entry with `PCurrencySymbol`
equivalent to the one specified in the `currencySym` field of the `Account` datum.

- to prevent DoS by token spamming the output going back to the `accountManager` MUST have at most length 2.

- there MUST be a single output going back to the `accountManager` contract with the following properties
    - it MUST have an entry for the `PCurrencySymbol` specified in the `currencySym` field of the `Account` (aka. NFT is preserved)
    - the output datum MUST be constructed using the `InlineDatum` constructor
    - the datum fields `credentials`, `currencySym` and `state` MUST be unchanged compared to the current datum.
    - the datum field `account.amount` MUST change based on `mint.amount` as described below:
        - if the `mint.amount` is positive the output datum MUST 
            be equal to the sum of `account.datum` and `mint.datum`
        - if the `amount` field included in the `Mint` redeemer is negative (aka. we are burning)
        the contract MUST FAIL if the sum of `mint.amount` and `account.amount` is strictly less than `0` (aka. burning more assets than how much the `Account` holds);
        otherwhise it MUST check for the output datum `amount` field to be equal to the result of the sum

#### `Transfer`

The `Transfer` redeemer is used to pay an other account in the same account manager.

When used as redeemer the contract checks for the following conditions to be true;

- `ownInputs` to be of lenght `2`

- `ownOuts` to be of lenght `2`

- to prevent DoS by tokne spam, every `ownOut` value must have length of `2`

- the receiver input (the `ownInput` with different `utxoRef` of the `validatingInput`)
being spent with `Receive` redeemer

- the receiver credentials present in the receiver datum (`receiverAccount.credentials`) MUST be equal to the `transfer.to` credentials present in the redeemer
(this allows for other potential contracts in the same transaction to only need to check the `Transfer` redeemer in order to understand who are the sender and the receiver)

- the sender input (`validatingInput`) MUST have the NFT according to `account.currencySym` (the input is valid)

- the output with the sender's credentials MUST preserve the NFT

- the sender account fields `credentials`, `currencySym` and `state` are unchanged between sender input datum and sender output datum

- the receiver account fields `credentials`, `currencySym` and `state` are unchanged between receiver input datum and receiver output datum

- the input sender's amount field is greather or equal than the redeemer amount (`transfer.amount`)

- the output sender's amount field is equal to the input one minus `transfer.amount`

- the output receiver's amount field is equal to the input one plus `transfer.amount`

- the sender singned the transaction (included in `ctx.tx.signatories` if a `PPubKeyHash` or included a script input if a `PValidatorHash`)

any additional check can be made based on the `account.state` (implementation specific)

#### `Receive`

- `ownInputs` to be of lenght `2`

- the `validatingInput` includes the NFT under the datum's `currencySym` field

- the sender input (the `ownInput` with different `utxoRef` of the `validatingInput`)
being spent with `Transfer` redeemer

- in the sender input `Transfer` redeemer the `amount` field is strictly grather than 0

> **NOTE**
>
> the sender input being an `ownInputs` element and being spent with `Transfer` redeemer 
> implies that the transfer calculation is running in that validation
>
> hence we don't need to perform the same calculation here

#### `ForwardCompatibility`

For the current version this redeemer SHOULD always fail.

The main purpose of the redeemer is to avoid breaking compatibilities for addtional implementation specific redeemers

## Rationale: how does this CIP achieve its goals?
<!-- The rationale fleshes out the specification by describing what motivated the design and what led to particular design decisions. It SHOULD describe alternate designs considered and related work. The rationale SHOULD provide evidence of consensus within the community and discuss significant objections or concerns raised during the discussion.

It MUST also explain how the proposal affects the backward compatibility of existing solutions when applicable. If the proposal responds to a CPS, the 'Rationale' section SHOULD explain how it addresses the CPS, and answer any questions that the CPS poses for potential solutions.
-->

The [first proposed implementation](https://github.com/cardano-foundation/CIPs/pull/444/commits/525ce39a89bde1ddb62e126e347828e3bf0feb58) was quite different by the one shown in this document

Main differences were in the proposed:
- [use of sorted merkle trees to prove uniqueness](https://github.com/cardano-foundation/CIPs/pull/444/commits/525ce39a89bde1ddb62e126e347828e3bf0feb58#diff-370b6563a47be474523d4f4dbfdf120c567c3c0135752afb61dc16c9a2de8d74R72) of an account during creation;
- account credentials as asset name

this path was abandoned due to the logaritmic cost of creation of accounts, on top of the complexity.

Other crucial difference with the first proposed implementation was in the `accountManager` redeemers;
which included definitions for `TransferFrom`, `Approve` and `RevokeApproval` redeemers, aiming to emulate ERC20's methods of `transferFrom` and `approve`;

after [important feedback by the community](https://github.com/cardano-foundation/CIPs/pull/444#issuecomment-1399356241), it was noted that such methods would not only have been superfluous, but also dangerous, and are hence removed in this specification.

The proposal does not affect backward compatibilty being the first proposing a standard for programmability over transfers;

exsisting native tokens are not conflicting for the standard, and instead are making it possible;
it would be infact much harder to prove the validity of an utxo without a native token on it.

## Path to Active

### Acceptance Criteria
<!-- Describes what are the acceptance criteria whereby a proposal becomes 'Active' -->

- having at least one instance of the smart contracts described on:
    - mainnet
    - preview testnet
    - preprod testnet
- having at least 2 different wallets integrating meta asset functionalities, mainly:
    - displayning balance of a specified meta asset if the user provides the address of the respecive account manager contract
    - transaction creation with `Transfer` redeemers

### Implementation Plan
<!-- A plan to meet those criteria. Or `N/A` if NOT applicable. -->

- [x] [PoC implementation](https://github.com/HarmonicLabs/erc20-like)
- [x] [showcase transactions](https://github.com/HarmonicLabs/erc20-like)
- [ ] wallet implementation 

## Copyright

This CIP is licensed under [CC-BY-4.0](https://creativecommons.org/licenses/by/4.0/legalcode).