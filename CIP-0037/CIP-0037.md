###### tags: `CIP`
# CIP-37
---
CIP: 37
Title: Plutus support for Pairings over BLS12_381
Authors: Iñigo Querejeta-Azurmendi <inigo.querejeta@iohk.io>
Discussions-To: https://github.com/cardano-foundation/CIPs/pull/219
Comments-URI: https://github.com/cardano-foundation/CIPs/pull/219
Status: Draft
Type: Standards Track
Created: 2022-02-11
License: Apache-2.0
---


## Abstract
This CIP proposes an extension of the current plutus functions to provide support for basic operations over BLS12_381 curve to the plutus language. We expose some candidate implementations, and describe clearly the benefits that this would bring. In a nutshell, pairing friendly curves will enable a large number of cryptographic primitives that will be essential for the scalability of Cardano. 

## Motivation
Pairing Friendly Curves are a type of curves that provide the functionality of computing pairings. A pairing is a binary function that maps two points from two groups to a third element in a third target group. For a more in-depth introduction to pairings, we recommend reading [Pairings for Beginners](https://www.craigcostello.com.au/tutorials) or [Pairings for Cryptographers](https://eprint.iacr.org/2006/165). In a nutshell, pairings enable a range of interesting cryptographic primitives which could (and will) be used for scaling Cardano and many other use cases. 

* **Sidechains** are a crucial component for the scalability of Cardano, and its interoperability with other chains/tokens/smart contracts. However, sidechains need to periodically commit their state to the Cardano mainnet to provide the same security guarantees as the latter. This periodical commitment is performed through a threshold signature by the dynamic committee of the Sidechain. The most interesting construction for medium sized committees is presented in the paper [Proof of Stake Sidechains](https://cointhinktank.com/upload/Proof-of-Stake%20Sidechains.pdf), in section 5.2 and requires pairings. We have yet not found an acceptable solution that does not require pairings.
* **Zero Knowledge Proofs** are an incredibly powerful tool. There exist different types of zero knowledge proofs, but the most succinct (and cheaper to verify) rely on pairings for verification. Zero knowledge proofs can be used to make Mithril certificates, or sidechain checkpoints even more succinct, or to create layer 2 solutions to provide scalability (by the means of [ZK-Rollups](https://ethereum.org/en/developers/docs/scaling/layer-2-rollups/), which are used to scale Ethereum, e.g. [Loopring](https://loopring.org/#/), [zkSync](https://zksync.io/) or [Aztec](https://aztec.network/) among others)
* **Hydra** is another crucial component for scalability of Cardano (there is a series of blog posts available, with a good summary of the solution [here](https://iohk.io/en/blog/posts/2021/09/17/hydra-cardano-s-solution-for-ultimate-scalability/)). Hydra relies on a multisignature scheme, where all participants of the side channel need to agree on the new state. This can be achieved with non-pairing friendly curves (as it is currently designed), but pairing based signature schemes provide much more elegant constructions that reduce interaction among signers. 
* **Mithril** currently does not require plutus support. However, Mithril, as a technology, allows for signature generation representing all stakeholders of Cardano (or any proof of stake system). These types of certificates might eventually be used for certifying sidechains, and plutus support will be crucial. Again, Mithril relies on pairing based signatures. 
* **ATALA** is a decentralized identification mechanism. One of the properties they want to provide is anonymity: users can selectively disclose attributes of their certificate or prove statements regarding them without disclosing their identity. Up to date, the most recent, efficient and interesting solutions to provide these are pairing based ([Hyperledger Fabric/Idemix standardisation effort](https://hyperledger-fabric.readthedocs.io/en/release-2.2/idemix.html#underlying-cryptographic-protocols), [coconut credentials used by Nym](https://blog.nymtech.net/nyms-coconut-credentials-an-overview-4aa4e922cd51), among others)


### Reason for choosing BLS12-381
The reason for choosing BLS12-381 over BN256 curve is that the former is claimed to provide 128 bits of security, while the latter was reduced to 100 bits of security after the extended number field sieve (a new algorithm to compute the discrete logarithm) was [shown to reduce the security](https://eprint.iacr.org/2016/1102.pdf) of these curves. 

An [EIP](https://eips.ethereum.org/EIPS/eip-2537) for precompiles of curve BLS12-381 already exists, but has been stagnant for a while. Nonetheless, Zcash, MatterLabs and Consensys support BLS12-381 curve, so it is certainly widely used in the space. 

Further reading regarding curve BLS12-381 can be found [here](https://hackmd.io/@benjaminion/bls12-381) and the references thereof cited. For level of detail required in this document, it is sufficient to understand that one can define a pairing over BLS12-381, where a pairing is a map: $e:G_{1}\times G_{2}\rightarrow G_{T}$, which satisfies the following properties:

* Bilinearity: $\forall a,b\in F_{q}^{*},\ \forall P\in G_{1},Q\in G_{2}:\ e\left(aP,bQ\right)=e\left(P,Q\right)^{ab}$
* Non-degeneracy: $e\neq 1$
* Computability: There exists an efficient algorithm to compute $e$

where $G_1, G_2$ and $G_T$ are three distinct groups of order a prime $q$. Given that all three groups have the same order, we can refer to the scalars of each group using the same type/structure. 

## Specification
We now provide the technical specification. 

### Names and types/kinds for the new functions or types
The added types will be the following, all of which can be represented as a byte array. Even if these types are equivalent to byte arrays of a given size, I think it makes sense to include these types for clarity of the code.
* `Bls12381G1Element`
* `Bls12381G2Element`
* `Bls12381GTElement`
* `Bls12381Scalar`

We need to support the binary operation of $G_1$ and $G_2$ (which are additive groups) as well as some operations over the scalars. In particular, we need the following functions: 

* Group operations: 
    * `BLS12_381_G1_add :: Bls12381G1Element -> Bls12381G1Element -> Bls12381G1Element`
    * `BLS12_381_G1_mult :: Bls12381Scalar -> Bls12381G1Element -> Bls12381G1Element`
    * `BLS12_381_G2_add :: Bls12381G2Element -> Bls12381G2Element -> Bls12381G2Element`
    * `BLS12_381_G2_mult :: Bls12381Scalar -> Bls12381G2Element -> Bls12381G2Element`
* Scalar operations: 
    * `BLS12_381_Scalar_mult :: Bls12381Scalar -> Bls12381Scalar -> Bls12381Scalar`
    * `BLS12_381_Scalar_add :: Bls12381Scalar -> Bls12381Scalar -> Bls12381Scalar`
    * `BLS12_381_Scalar_inv :: Bls12381Scalar -> Bls12381Scalar`
    * `BLS12_381_Scalar_neg :: Bls12381Scalar -> Bls12381Scalar`
* Pairing operations:
    * `BLS12_381_pairing :: Bls12381G1Element -> Bls12381G2Element -> Bls12381GTElement` 


### Source implementations
* [BLST](https://github.com/supranational/blst) library
* [ZCash](https://github.com/zkcrypto/pairing)'s library
* [Consensys](https://github.com/ConsenSys/gnark)' library

Other libraries of interest
* [Ethereum support for BLS12-381](https://eips.ethereum.org/EIPS/eip-2537). Not directly relevant as this is a Ethereum Improvement Proposal for a precompiled solidity contracts.

### Comparison with existing function
We present what would be the alternatives of using pairings in the different usecases presented above. 

* Sidechain bridges using the current technology would rely on either of the two possibilities: 
    * Require the bridge committee to interact during signature, or to rely on a precomputation phase. Current solutions only support non-robust signature schemes, meaning that if one signer misbehaves, the whole signature procedure needs to be restarted. This could seriously hinder sidechains.
    * Non-aggregation of signatures. This would result in a linear "checkpoint certificate" with respect to the number of signers (both in communication and computation complexity). Basically, all committee members need to submit their signature, and the smart contract needs to verify all ed25519 signatures. 
* Zero Knowledge Proofs cannot be verified with current functions available in Plutus. There exists proofs that can be instantiated over non-pairing friendly curves, but these result in logarithmic sized proofs with respect to the computation to prove, while solutions that rely on pairings can be represented more concisely. 

### Reason for exposing curve operations API
One might be concerned of why we are exposing such low-level primitives, instead of exposing higher level protocol functions, such as $\texttt{VerifyBlsSignature}$ or $\texttt{VerifyZKP}$. The motivation behind that is because pairings can enable a big number of use cases, and covering all of those can considerably extend the list of required functions.. 

### Curve specifications
BLS12 curve is fully defined by the following set of parameters (coefficient A=0 for all BLS12 curves). Taken from [EIP 2537](https://eips.ethereum.org/EIPS/eip-2537):
```
Base field modulus = 0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab
B coefficient = 0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004
Main subgroup order = 0x73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001
Extension tower
Fp2 construction:
Fp quadratic non-residue = 0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaaa
Fp6/Fp12 construction:
Fp2 cubic non-residue c0 = 0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001
Fp2 cubic non-residue c1 = 0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001
Twist parameters:
Twist type: M
B coefficient for twist c0 = 0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004
B coefficient for twist c1 = 0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004
Generators:
G1:
X = 0x17f1d3a73197d7942695638c4fa9ac0fc3688c4f9774b905a14e3a3f171bac586c55e83ff97a1aeffb3af00adb22c6bb
Y = 0x08b3f481e3aaa0f1a09e30ed741d8ae4fcf5e095d5d00af600db18cb2c04b3edd03cc744a2888ae40caa232946c5e7e1
G2:
X c0 = 0x024aa2b2f08f0a91260805272dc51051c6e47ad4fa403b02b4510b647ae3d1770bac0326a805bbefd48056c8c121bdb8
X c1 = 0x13e02b6052719f607dacd3a088274f65596bd0d09920b61ab5da61bbdc7f5049334cf11213945d57e5ac7d055d042b7e
Y c0 = 0x0ce5d527727d6e118cc9cdc6da2e351aadfd9baa8cbdd3a76d429a695160d12c923ac9cc3baca289e193548608b82801
Y c1 = 0x0606c4a02ea734cc32acd2b02bc28b99cb3e287e85a763af267492ab572e99ab3f370d275cec1da1aaa9075ff05f79be
Pairing parameters:
|x| (miller loop scalar) = 0xd201000000010000
x is negative = true
```
One should note that base field modulus is equal to 3 mod 4 that allows an efficient square root extraction.

## Moving to Proposed
### Trustworthiness of implementations
* [BLST](https://github.com/supranational/blst) library—[audited by NCC Group](https://research.nccgroup.com/wp-content/uploads/2021/01/NCC_Group_EthereumFoundation_ETHF002_Report_2021-01-20_v1.0.pdf) and [being formally verified](https://github.com/GaloisInc/BLST-Verification) by Galois
* [ZCash](https://github.com/zkcrypto/pairing)'s library---used by zcash to validate ZKSNARKs at scale. 
* [Consensys](https://github.com/ConsenSys/gnark)' library---
### Costing of function
We now describe the relation of evaluating the functions described above with respect to ed25519 verification. This estimates will be more precise once we decide which library to go forward with. We represent each function cost as a ratio wrt to ed25519 verification (op / ed25519_verif):
* `BLS12_381_G1_add`: 0,016
* `BLS12_381_G1_mult`: 4,018
* `BLS12_381_G2_add`: 0,054
* `BLS12_381_G2_mult`: 13,8
* `BLS12_381_Scalar_mult`: 0,0000003
* `BLS12_381_Scalar_add`: 0,0000003
* `BLS12_381_Scalar_inv`: 0,036
* `BLS12_381_Scalar_neg`: 0,0000003
* `BLS12_381_pairing`: 30,58
### Plutus implementor
IOHK internal

