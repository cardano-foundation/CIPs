---
CIP: 0087
Title: Integer-ByteString conversions
Category: Plutus
Status: Proposed
Authors:
    - Koz Ross <koz@mlabs.city>
Implementors: []
Discussions:
    - https://github.com/cardano-foundation/cips/pulls/?
Created: 2023-11-17
License: CC-BY-4.0
---

<!-- Existing categories:

- Meta     | For meta-CIPs which typically serves another category or group of categories.
- Wallets  | For standardisation across wallets (hardware, full-node or light).
- Tokens   | About tokens (fungible or non-fungible) and minting policies in general.
- Metadata | For proposals around metadata (on-chain or off-chain).
- Tools    | A broad category for ecosystem tools not falling into any other category.
- Plutus   | Changes or additions to Plutus
- Ledger   | For proposals regarding the Cardano ledger (including Reward Sharing Schemes)
- Catalyst | For proposals affecting Project Catalyst / the JÃ¶rmungandr project

-->

## Abstract

<!-- A short (\~200 word) description of the proposed solution and the technical issue being addressed. -->

## Motivation: why is this CIP necessary?

Plutus Core creates a strong abstraction boundary between the concepts of
'number' (represented by `BuiltinInteger`) and 'blob of bytes' (represented by
`BuiltinByteString`), defining different sets of (largely non-overlapping)
operations for each. This is, in principle, a good practice, as these concepts
are distinct in (most of) the operations that make sense on them. However,
sometimes, being able to 'move between' these two 'worlds' is important: namely,
the ability to represent a given `BuiltinInteger` as a `BuiltinByteString`, as
well as to convert between this representation and the `BuiltinInteger` it
represents. Currently, no such capability exists: while [CIP-0058][cip-0058]
proposed such a capability (among others), to date, this has not been
implemented into Plutus Core.

To see why such a capability would be beneficial, we give two motivating use
cases.

### Case 1: signing bids

Consider the following code snippet:

```haskell
validBidTerms :: AuctionTerms -> CurrencySymbol -> BidTerms -> Bool
validBidTerms AuctionTerms {..} auctionID BidTerms {..}
  | BidderInfo {..} <- bt'Bidder =
  validBidderInfo bt'Bidder &&
  -- The bidder pubkey hash corresponds to the bidder verification key.
  verifyEd25519Signature at'SellerVK
    (sellerSignatureMessage auctionID bi'BidderVK)
    bt'SellerSignature &&
  -- The seller authorized the bidder to participate
  verifyEd25519Signature bi'BidderVK
    (bidderSignatureMessage auctionID bt'BidPrice bi'bidderPKH)
    bt'BidderSignature
  -- The bidder authorized the bid

bidderSignatureMessage
  :: CurrencySymbol
  -> Integer
  -> PubKeyHash
  -> BuiltinByteString
bidderSignatureMessage auctionID bidPrice bidderPKH =
  toByteString auctionID <>
  toByteString bidPrice <>
  toByteString bidderPKH

sellerSignatureMessage
  :: CurrencySymbol
  -> BuiltinByteString
  -> BuiltinByteString
sellerSignatureMessage auctionID bidderVK =
  toByteString auctionID <>
  bidderVK
```

Here, we attempt to verify (using the Curve25519) that a bid at an auction was
signed by a particular bidder. The message to verify must include the bid
placed, represented using `Integer` here (which translates to `BuiltinInteger`
onchain). However, the `verifyEd25519Signature` primitive can only accept
`BuiltinByteString`s as messages to verify. Thus, we have a problem: how to
include the placed bid into the bid message to be verified?

### Case 2: finite fields

[Finite fields][finite field], also known as Galois fields, are a common
algebraic structure in cryptographic constructions. Many, if not most, common
constructions in cryptography use finite fields as their basis, including
[Curve25519][curve-25519], [Curve448][curve-448] and the [Pasta
curves][pasta-curves], to name but a few. Elements in a finite field are
naturally representable as `BuiltinInteger`s of bounded size onchain, but for
applications like the constructions specified above (and indeed, anything built
atop such constructions), we need to be able to perform the following tasks
efficiently:

* Verify that a particular value belongs to the field; and
* Perform bitwise (that is, non-numerical) operations on such values, possibly
  together with numerical ones.

Furthermore, this case presents two further challenges: _endianness_ and
_padding_. Due to many cryptographic algorithms being designed for use over the
network, their specifications assume a big-endian byte ordering in their
implementations. Likewise, due to the finiteness of a finite field's elements, 
which implementations use for both convenience and efficiency.

[cip-0058]: https://github.com/cardano-foundation/CIPs/tree/master/CIP-0058
[finite-field]: https://en.wikipedia.org/wiki/Finite_field
[curve-25519]: https://en.wikipedia.org/wiki/Curve25519
[curve-448]: https://en.wikipedia.org/wiki/Curve448
[pasta-curves]: https://electriccoin.co/blog/the-pasta-curves-for-halo-2-and-beyond/

--- 

While it is not outright impossible to perform conversions from `BuiltinInteger`
to `BuiltinByteString` currently, it is unreasonably difficult and
resource-intensive: `BuiltinInteger` to `BuiltinByteString` involves a repeated
combination of division-with-remainder in a loop, while `BuiltinByteString` to
`BuiltinInteger` involves repeated multiplications by large constants and
accumulations. Aside from these both requiring looping (with the overheads this
imposes), both of these are effectively quadratic operations with current
primitives: the only means we have to accumulate `BuiltinByteString`s is by
consing or appending (which are both quadratic due to `BuiltinByteString` being
a counted array), and any `BuiltinInteger` operation is linear in the size of
its arguments. This makes even case 1 far more effort, both for the developer and
the node, than it should be, and case 2 ranges from difficult to impossible once
we factor in the limited available primitive operations and the endianness and
padding problems.

We propose that two primitives be added to Plutus Core: one for converting
`BuiltinInteger`s to `BuiltinByteString`s, the other for converting
`BuiltinByteString`s to `BuiltinInteger`s. The first of these primitives would
allow for specifying an endianness for the result, as well as to perform padding
to a required length if necessary; the second primitive is able to operate on
padded or unpadded encodings, in either endianness.

Additionally, we state the following goals that any implementation of such
primitives must have.

### No metadata

The representation produced by the `BuiltinInteger` to `BuiltinByteString`
conversion should be 'minimal', representing only the number being given to it,
and no other information besides. It would be tempting to, for example, encode
the endianness requested into the `BuiltinByteString`, but ultimately, this
information could be added later by users if they want it, while removing it
would be trickier. Additionally, metadata-related concerns would complicate both
the specification and implementation of the primitives, for arguably marginal
benefit.

### Internals-independence

Users of these primitives should not need to know how _exactly_
`BuiltinInteger`s are represented to use them successfully. This is beneficial
to both users (as they now don't have to concern themselves with
platform-specific implementation issues) and Plutus Core maintainers (as changes
in the representation of `BuiltinInteger` aren't going to affect these
primitives).

### No support for negative numbers

While for fixed-size numbers, [two's-complement][twos-complement] is the default
choice for negative number representations, for arbitrary-size numbers, there is
no agreed-upon choice. Furthermore, indicating the 'negativity' of a number
would require making representations larger or more complex regardless of which
representation we chose, while also complicating both the primitives we want to
define, and any user-defined operations on such representations, possibly in
ways that users do not want. Lastly, for our cases, negative values are not
really needed, and if the ability to encode negative numbers was necessary,
users could still define whichever one(s) they needed themselves, with little
effort or computational cost.

[twos-complement]: https://en.wikipedia.org/wiki/Two%27s_complement

## Specification

We describe the specification of two Plutus Core primitives, which will have the
following signatures:

* `builtinIntegerToByteString :: BuiltinBool -> BuiltinInteger -> BuiltinInteger
  -> BuiltinByteString`
* `builtinByteStringToInteger :: BuiltinBool -> BuiltinByteString ->
  BuiltinInteger`

To describe the semantics of these primitives, we first specify how we represent
a `BuiltinInteger` as a `BuiltinByteString`; after that, we describe the two
primitives, as well as giving some properties they must follow.

### Representation

Our `BuiltinByteString` representations of non-negative `BuiltinInteger`s treat
the `BuiltinInteger` being represented as a sequence of digits in base-256.
Thus, any byte in the `BuiltinByteString` representation corresponds to a single
base-256 digit, whose digit value is equal to its value as an 8-bit unsigned
integer. For example, the byte `0x80` would have digit value 128, while the byte
`0x03` would have digit value 3.

To determine place value, we define two possible arrangements of digits in such
a representation: _most-significant-first_, and _most-significant-last_. In the
most-significant-first representation, the first digit (that is, the byte at
index 0) has the highest place value; in the most-significant-last
representation, the first digit instead has the _lowest_ place value. These
correspond to the notions of [big-endian and little-endian][endianness]
respectively.

For any positive `BuiltinInteger` `i`, let 

$$i_0 \circ 256^0 + i_1 \circ 256^1 + \ldots + i_k \circ 256^k$$

be its [base-256 form][base-256-form]. Then, for the most-significant-first
representation, the `BuiltinByteString` encoding for `i` is the
`BuiltinByteString` `b` such that `indexByteString bs j = ` $i_{k - j}$. For
the most-significant-last encoding, we instead have `indexByteString bs j = `
$i_j$.

[base-256-form]: https://en.wikipedia.org/wiki/Numeral_system#Positional_systems_in_detail

For example, consider the number `123_456`. Its base-256 form is 

```
64 * 256 ^ 0 + 226 * 256 ^ 1 + 1 * 256 ^ 2
```

Therefore, its most-significant-first representation would be

```
[ 0x01, 0xC2, 0x80 ]
```

while its most-significant-last representation would be

```
[ 0x80, 0xC2, 0x01 ]
```

For `0`, we define both its most-significant-first and most-significant-last
representation as `[ 0x00 ]` (that is, one zero byte).

To represent any given non-negative `BuiltinInteger` `i` as above, we require 
a minimum number of base-256 digits. For positive `i`, this is 
$\max \\{1, \ceil(\log_{256}(\textt{i}))\\}$; for `i = 0`, we define this to be
$1$. We can choose to represent `i` with more digits than this minimum, by the
use of _padding_. Let $k$ be the minimum number of digits to represent `i`, and
let $j$ be a positive number: to represent `i` using $k + j$ digits in the
most-significant-first encoding, we set the first $j$ bytes of the encoding as
`0x0`; for the most-significant-last encoding, we set the _last_ $j$ bytes of
the encoding as `0x0` instead.

[endianness]: https://en.wikipedia.org/wiki/Endianness

To extend our previous example, a five-digit, most-significant-first 
representation of `123_456` is

```
[ 0x00, 0x00, 0x01, 0xC2, 0x80 ]
```

while the most-significant-last representation would be

```
[ 0x80, 0xC2, 0x01, 0x00, 0x00 ]
```

We observe that these extra digits do not change what exact `BuiltinInteger` is
represented, as any zero digit has zero place value.

### `builtinIntegerToByteString`

We can now describe the semantics of the `builtinIntegerToByteString` 
primitive. The `builtinIntegerToByteString` function takes three arguments, in
the listed order:

1. Whether the most-significant-first encoding should be used;
2. The minimum number of digits required in the output; and
3. The `BuiltinInteger` to convert.

If argument 3 is negative, `builtinIntegerToByteString` fails. In this case, the
resulting error message must specify _at least_ the following information:

* That `builtinIntegerToByteString` failed due to a negative conversion attempt
* What negative `BuiltinInteger` was passed as argument 3

If argument 3 is `0` and argument 2 is positive, `builtinIntegerToByteString`
returns the `BuiltinByteString` consisting of a number of zero bytes equal to
argument 2; if argument 2 is non-positive, `builtinIntegerToByteString` returns
the `BuiltinByteString` consisting of a single zero byte.

If argument 3 is positive, `builtinIntegerToByteString` returns the
`BuiltinByteString` corresponding to the most-significant-first, or
most-significant-last, encoding of argument 3, as specified by argument 1. If
argument 2 is greater than the minimum number of digits needed to represent
argument 3, the result is padded to the number of digits specified by argument
2; otherwise, no padding is done.

We describe properties that any `builtinIntegerToByteString` must have.
Throughout, `i` is not negative, and `k` is positive.

1. `indexByteString (builtinIntegerToByteString False d i) 0 = remainderInteger
   i 256`
2. `let result = builtinIntegerToByteString True d i in indexByteString result
   (lengthOfByteString result - 1) = remainderInteger i 256`

## `builtinByteStringToInteger`

The `builtinByteStringToInteger` primitive takes two arguments, in the listed
order:

1. Whether the encoding in argument 2 is most-significant-first;
2. The `BuiltinByteString` to convert.

If argument 2 is the empty `BuiltinByteString`, `builtinByteStringToInteger`
fails. In this case, the resulting error message must specify that
`builtinByteStringToInteger` failed because it was asked to convert the empty
`BuiltinByteString`.

If argument 2 is non-empty, `builtinByteStringToInteger` produces the
`BuiltinInteger` encoded by argument 2. The encoding is treated as either
most-significant-first or most-significant-last, as per argument 1. The encoding
in argument 2 may be padded or not.

We describe properties that any `builtinByteStringToInteger` implementation 
must have. Throughout, @i@ is not negative, and @0 <= w8 <= 255@.

1. `builtinByteStringToInteger b (builtinIntegerToByteString b k i) = i`
2. `builtinByteStringToInteger b (consByteString w8 emptyByteString) = w8`

## Rationale: how does this CIP achieve its goals?


<!-- The rationale fleshes out the specification by describing what motivated the design and what led to particular design decisions. It should describe alternate designs considered and related work. The rationale should provide evidence of consensus within the community and discuss significant objections or concerns raised during the discussion.

It must also explain how the proposal affects the backward compatibility of existing solutions when applicable. If the proposal responds to a CPS, the 'Rationale' section should explain how it addresses the CPS, and answer any questions that the CPS poses for potential solutions.
-->

## Path to Active

### Acceptance Criteria
<!-- Describes what are the acceptance criteria whereby a proposal becomes 'Active' -->

### Implementation Plan
<!-- A plan to meet those criteria. Or `N/A` if not applicable. -->

## Copyright
<!-- The CIP must be explicitly licensed under acceptable copyright terms. -->

[CC-BY-4.0]: https://creativecommons.org/licenses/by/4.0/legalcode
[Apache-2.0]: http://www.apache.org/licenses/LICENSE-2.0
