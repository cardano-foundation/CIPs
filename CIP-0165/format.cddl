; This is temporary file, because currently data record data is not
; in CBOR format. However this cddl format is very readable so we
; use it as a pseudo-code.


scls = [* record]
record = (size: uint32, chunk_type: uint .size 1, payload: any)

slot_no = uint .size 8

; ----- HDR -----
hdr = {
  magic: bstr .size 5,      ; "SCLS\x00"
  version: uint16,          ; starting with 1
  network_id: uint .size 1, ; 0 - mainnet , 1 - testnet
  slot_no: slot_no,         ; slot_no when file was created
}

; ----- Entry -----
entry = {
  size: uint .size 4        ; size of entry
  key: bstr,                ; key of the data, basically any cbor
  value: bstr               ; value of the data, basically any cbor
}

; ----- CHUNK -----
chunk = {
  chunk_seq: uint .size 8      ; sequence number of the chunk (used for data integrity)
  chunk_format: uint .size 1,  ; 0 - raw, 1 - zstd, 2 - zstde
  namespace: tstr,             ; string representation of the chunk values namespace
  entries: bstr                ; [* entry] - list of entries, packed as described by the chunk_format
  footer: {
    entries_cnt: uint .size 4, ; count of entries
    chunk_hash: bstr .size 28  ; H(concat (digest e for e in entries))
  }
}

; ----- DELTA -----
; WIP is not considered as a fixed format in this version of CIP
delta = {
  chunk_seq: uint .size 8,     ; sequence number
  namespace: bstr,             ; namespace for the delta record
  chunk_format: uint,          ; 0 - raw, 1 - zstd, 2 - zstde
  changes: bstr                ; [* entry] â€” list of entries, tombstone allowed
  footer: {
    entries_cnt: uint .size 4  ; count of entries
    chunk_hash: bstr .size 28  ; H(concat (digest e for e in entries))
  }
}

change_entry = tombstone_entry // delta_value_entry

tombstone_entry = (0, key: bstr )
delta_value_entry = (1, key: bstr, ?value: bstr)

; ----- MANIFEST -----
manifest = {
  total_entries: uint .size 8,             ; number of entries so far (for integrity)
  total_chunks: uint .size 8,              ; number of chunks so far (for integrity)
  root_hash: bstr,                         ; multihash of the entries
  prev_manifest_offset: 0 // uint .size 8, ; offset of the previous manifest entry (required with delta)
  summary: {
    created_at: tstr,                      ; date
    tool: tstr,                            ; information about tool
    ?comment: tstr                         ; additional comments
  }
  ns_info: { * tstr => bstr .size 28 },    ; blake28 of the entries
  manifest_offset: uint .size 4,           ; offset to the start of the manifest entry block
}

; This spec is not precise here, because we have
; a binary format and not cbor. Instead we use the following encoding:
;   uint .usize  4 - for string length
;   uint .usize  8 - for number of entries
;   uint .usize  8 - for number of chunks
;   .bstr .size 28 - for hash
ns_info = {
  ns_entries: uint .size 8,                ; entries count
  ns_chunks: uint .size 8,                 ; chunks count
  hash: bstr .size 28,                     ; blake28 merkle tree hash for the entries
}

; ----- BLOOM -----
; WIP is not considered as a fixed format in this version of CIP
bloom = {
  chunk_seq: uint,
  m: uint,
  k: uint,
  bitset: bstr
}

; ----- INDEX -----
; WIP is not considered as a fixed format in this version of CIP
index = {
  kind: uint,
  items: [* any] ; interpretation depends on kind
}

; ----- DIR -----
; WIP is not considered as a fixed format in this version of CIP
dir = {
  magic_dir: bstr .size 4, ; "SCLD"
  manifest_offset: uint,
  index_region_offset: { * tstr => uint },
  meta_region_offset: { * tstr => uint },
}

; ----- META -----
meta = {
  entries: [* meta_entry]
  footer: {
    entries_cnt: uint .size 4  ; count of entries
    chunk_hash: bstr .size 28  ; H(concat (digest e for e in entries))
  }
}
meta_entry = {
  subject: uri, ; URI
  value: bstr ; multihash
}