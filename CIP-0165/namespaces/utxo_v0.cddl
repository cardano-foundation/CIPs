; This file was auto-generated from huddle.
; Source: https://github.com/tweag/cardano-cls/blob/main/scls-cardano/cddl-src/Cardano/SCLS/Namespace/UTxO.hs

;  The key for the entry is one of the following:
;
;  ```
;  meta:
;    endian: be
;
;  seq:
;    - id: key
;      type: utxo_key
;
;  types:
;    utxo_key:
;      seq:
;       - id: tx_addr
;         doc: transaction
;         type: bytes
;         size: 28
;       - id: tx_idx
;         doc: index inside transaction
;         type: u4
;  ```
;
record_entry = tx_out

tx_out = bytes .cbor rule

rule = shelley_tx_out/ babbage_tx_out

shelley_tx_out = [address, amount : value, ? datum_hash : hash32]

address = bytes

value = coin/ [coin, multiasset<positive_coin>]

coin = uint

multiasset<a0> = {* policy_id => {+ asset_name => a0}}

policy_id = hash28

hash28 = bytes .size 28

asset_name = bytes .size (0 .. 32)

positive_coin = 1 .. 18446744073709551615

hash32 = bytes .size 32

; NEW starting with babbage
;   datum_option
;   script_ref
babbage_tx_out = {0 : address, 1 : value, ? 2 : datum_option, ? 3 : script_ref}

datum_option = [0, hash32// 1, data]

data = #6.24(bytes .cbor plutus_data)

plutus_data =
  constr<plutus_data>
  / {* plutus_data => plutus_data}
  / [* plutus_data]
  / big_int
  / bytes

; NEW
;   #6.102([uint, [* a]]): For tag range 6.1280 .. 6.1400 inclusive
constr<a0> =
  #6.122([* a0])
  / #6.123([* a0])
  / #6.124([* a0])
  / #6.125([* a0])
  / #6.126([* a0])
  / #6.127([* a0])
  / #6.1280([* a0])
  / #6.1281([* a0])
  / #6.1282([* a0])
  / #6.1283([* a0])
  / #6.1284([* a0])
  / #6.1285([* a0])
  / #6.1286([* a0])
  / #6.1287([* a0])
  / #6.1288([* a0])
  / #6.1289([* a0])
  / #6.1290([* a0])
  / #6.1291([* a0])
  / #6.1292([* a0])
  / #6.1293([* a0])
  / #6.1294([* a0])
  / #6.1295([* a0])
  / #6.1296([* a0])
  / #6.1297([* a0])
  / #6.1298([* a0])
  / #6.1299([* a0])
  / #6.1300([* a0])
  / #6.1301([* a0])
  / #6.1302([* a0])
  / #6.1303([* a0])
  / #6.1304([* a0])
  / #6.1305([* a0])
  / #6.1306([* a0])
  / #6.1307([* a0])
  / #6.1308([* a0])
  / #6.1309([* a0])
  / #6.1310([* a0])
  / #6.1311([* a0])
  / #6.1312([* a0])
  / #6.1313([* a0])
  / #6.1314([* a0])
  / #6.1315([* a0])
  / #6.1316([* a0])
  / #6.1317([* a0])
  / #6.1318([* a0])
  / #6.1319([* a0])
  / #6.1320([* a0])
  / #6.1321([* a0])
  / #6.1322([* a0])
  / #6.1323([* a0])
  / #6.1324([* a0])
  / #6.1325([* a0])
  / #6.1326([* a0])
  / #6.1327([* a0])
  / #6.1328([* a0])
  / #6.1329([* a0])
  / #6.1330([* a0])
  / #6.1331([* a0])
  / #6.1332([* a0])
  / #6.1333([* a0])
  / #6.1334([* a0])
  / #6.1335([* a0])
  / #6.1336([* a0])
  / #6.1337([* a0])
  / #6.1338([* a0])
  / #6.1339([* a0])
  / #6.1340([* a0])
  / #6.1341([* a0])
  / #6.1342([* a0])
  / #6.1343([* a0])
  / #6.1344([* a0])
  / #6.1345([* a0])
  / #6.1346([* a0])
  / #6.1347([* a0])
  / #6.1348([* a0])
  / #6.1349([* a0])
  / #6.1350([* a0])
  / #6.1351([* a0])
  / #6.1352([* a0])
  / #6.1353([* a0])
  / #6.1354([* a0])
  / #6.1355([* a0])
  / #6.1356([* a0])
  / #6.1357([* a0])
  / #6.1358([* a0])
  / #6.1359([* a0])
  / #6.1360([* a0])
  / #6.1361([* a0])
  / #6.1362([* a0])
  / #6.1363([* a0])
  / #6.1364([* a0])
  / #6.1365([* a0])
  / #6.1366([* a0])
  / #6.1367([* a0])
  / #6.1368([* a0])
  / #6.1369([* a0])
  / #6.1370([* a0])
  / #6.1371([* a0])
  / #6.1372([* a0])
  / #6.1373([* a0])
  / #6.1374([* a0])
  / #6.1375([* a0])
  / #6.1376([* a0])
  / #6.1377([* a0])
  / #6.1378([* a0])
  / #6.1379([* a0])
  / #6.1380([* a0])
  / #6.1381([* a0])
  / #6.1382([* a0])
  / #6.1383([* a0])
  / #6.1384([* a0])
  / #6.1385([* a0])
  / #6.1386([* a0])
  / #6.1387([* a0])
  / #6.1388([* a0])
  / #6.1389([* a0])
  / #6.1390([* a0])
  / #6.1391([* a0])
  / #6.1392([* a0])
  / #6.1393([* a0])
  / #6.1394([* a0])
  / #6.1395([* a0])
  / #6.1396([* a0])
  / #6.1397([* a0])
  / #6.1398([* a0])
  / #6.1399([* a0])
  / #6.1400([* a0])
  / #6.121([* a0])
  / #6.102([uint, [* a0]])

big_int = int/ big_uint/ big_nint

big_uint = #6.2(bounded_bytes)

; The real bounded_bytes does not have this limit. it instead has
; a different limit which cannot be expressed in CDDL.
;
; The limit is as follows:
;  - bytes with a definite-length encoding are limited to size 0..64
;  - for bytes with an indefinite-length CBOR encoding, each chunk is
;    limited to size 0..64
;  ( reminder: in CBOR, the indefinite-length encoding of
;  bytestrings consists of a token #2.31 followed by a sequence
;  of definite-length encoded bytestrings and a stop code )
bounded_bytes = bytes .size (0 .. 64)

big_nint = #6.3(bounded_bytes)

script_ref = #6.24(bytes .cbor script)

script =
  [  0, native_script
  // 1
  , bytes
  // 2
  , bytes
  // 3
  , bytes
  ]


native_script =
  [  script_pubkey
  // script_all
  // script_any
  // script_n_of_k
  // invalid_before
  // invalid_hereafter
  ]


script_pubkey = (0, hash28)

script_all = (1, [* native_script])

script_any = (2, [* native_script])

script_n_of_k = (3, n : int64, [* native_script])

int64 = -9223372036854775808 .. 9223372036854775807

invalid_before = (4, slot_no)

slot_no = uint .size 8

invalid_hereafter = (5, slot_no)

